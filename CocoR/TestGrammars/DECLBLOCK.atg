
/* Imports here are inserted at the top of the generated lexer and parser. */
import afs.nodes.def.*;
import afs.nodes.event.*;
import afs.nodes.expr.*;
import afs.nodes.prog.*;
import afs.nodes.stmt.*;
import afs.nodes.type.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;

/* The required start of a Coco/R grammar file. "Program" specifies the starting symbol of the grammar. */
COMPILER Program
/* Code here is injected at the start of the parser class. */
/*-----------------------------------Helper functions-----------------------------------*/

public StmtNode mainNode = null; // This contains the AST generated by calling parser.Parse().

public boolean hasErrors() {
return errors.count > 0;
}

private StmtNode declToCompStmt(List<StmtNode> stmts) {
if (stmts.isEmpty()) {
return new StmtSkipNode();
}
StmtNode left = stmts.getFirst();

if (stmts.size() == 1) {
return addReturnIfDeclaration(left);
} else {
int line = left.getLineNumber();
int col = left.getColumnNumber();
List<StmtNode> rest = stmts.subList(1, stmts.size());
StmtNode right = declToCompStmt(rest);
if (left instanceof StmtDeclarationNode) {
return new StmtDeclarationNode(
((StmtDeclarationNode) left).getType(),
((StmtDeclarationNode) left).getIdentifier(),
((StmtDeclarationNode) left).getExpression(),
right, line, col);
} else {
return new StmtCompositionNode(left, right, line, col);
}
}
}
private StmtNode addReturnIfDeclaration(StmtNode stmt) {
if (stmt instanceof StmtDeclarationNode) {
int line = stmt.getLineNumber();
int col = stmt.getColumnNumber();
ExprIdentifierNode ident = new ExprIdentifierNode(((StmtDeclarationNode) stmt).getIdentifier(), line, col);
StmtReturnNode ret = new StmtReturnNode(ident, line, col);
System.out.println("Inserting return statement for " + ident.getIdentifier());
return new StmtDeclarationNode(((StmtDeclarationNode) stmt).getType(), ((StmtDeclarationNode) stmt).getIdentifier(), ((StmtDeclarationNode) stmt).getExpression(), ret, line, col);
} else {
return stmt;
}
}

private ExprNode makeUnOpExpr(List<Character> unaries, ExprNode base, int line, int col) {
ExprNode result = base;
int index = 0;
while (index < unaries.size()) {
char ch = unaries.get(index);
result = switch (ch) {
case '!' -> new ExprUnopNode(result, UnOp.NOT, line, col);
case '-' -> new ExprUnopNode(result, UnOp.NEG, line, col);
default -> throw new RuntimeException("Unknown unary operator: " + ch);
};
index++;
}
return result;
}

private ExprNode makeBinOpExpr(ExprNode left, String op, ExprNode right, int line, int column) {
return switch (op) {
case "*" -> new ExprBinopNode(left, BinOp.MUL, right, line, column);
case "/" -> new ExprBinopNode(left, BinOp.DIV, right, line, column);
case "+" -> new ExprBinopNode(left, BinOp.ADD, right, line, column);
case "-" -> new ExprBinopNode(left, BinOp.SUB, right, line, column);
case "++" -> new ExprBinopNode(left, BinOp.CONCAT, right, line, column);
case "<=" -> {  ExprNode equals = makeBinOpExpr(left, "==", right, line, column);
ExprNode lessThan = makeBinOpExpr(left, "<", right, line, column);
yield makeBinOpExpr(equals, "||", lessThan, line, column);
}
case ">=" -> {  ExprNode equals = makeBinOpExpr(left, "==", right, line, column);
ExprNode lessThan = makeBinOpExpr(left, ">", right, line, column);
yield makeBinOpExpr(equals, "||", lessThan, line, column);
}
case "<" -> new ExprBinopNode(left, BinOp.LT, right, line, column);
case ">" -> new ExprBinopNode(right, BinOp.LT, left, line, column);
case "==" -> new ExprBinopNode(left, BinOp.EQ, right, line, column);
case "!=" -> {  ExprNode equal = makeBinOpExpr(left, "==", right, line, column);
yield new ExprUnopNode(equal, UnOp.NOT, line, column);
}
case "&&" -> new ExprBinopNode(left, BinOp.AND, right, line, column);
case "||" -> {  ExprNode notLeftExpr = new ExprUnopNode(left, UnOp.NOT, line, column);
ExprNode notRightExpr = new ExprUnopNode(right, UnOp.NOT, line, column);
ExprNode andNode = makeBinOpExpr(notLeftExpr, "&&", notRightExpr, line, column);
yield new ExprUnopNode(andNode, UnOp.NOT, line, column);
}
default -> throw new RuntimeException("Unknown binary operator: " + op);
};
}

/*------------------------------------------------------------------------*/
/* The following section contains the token specification of AFS.*/
CHARACTERS
letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
digit = "0123456789" .
lf  = '\n' .

TOKENS
INT = digit {digit} .
DOUBLE = digit {digit} "." digit {digit} .
STRING = '"' { letter | digit } '"' .
IDENT  = ('_' | letter) {letter | digit | '_'} .

COMMENTS FROM "/*" TO "*/" NESTED  /* Nested means: "There can be comments inside comments" */
COMMENTS FROM "//" TO lf

IGNORE '\r' + '\n' + '\t' /* These characters are ignored by the lexer */

/*------------------------------------------------------------------------*/
/* The rest of the file contains the grammar for AFS.  */
PRODUCTIONS

Program = DeclBlock<out mainNode> .

/*-----------------------------------Declarations-----------------------------------*/
DeclBlock<out StmtNode stmt> = (. List<StmtNode> decls = new ArrayList<>(); .)
"{"
{ Decl<out StmtNode decl> (. decls.add(decl); .)
}
"}" (. stmt = declToCompStmt(decls); .)
.

Decl<out StmtNode decl> = (. decl = new StmtSkipNode(); .)
( DeclDecl<out decl>
| DeclIf<out decl>
| DeclExpr<out ExprNode expr> ";" (. decl = new StmtReturnNode(expr, t.line, t.col); .) )
.

DeclDecl<out StmtNode decl> = (. ExprNode declExpr = null; .)
DeclType<out TypeNode type>
IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
"="
( DeclExpr<out declExpr>
| Expr<out declExpr> ) (. decl = new StmtDeclarationNode(type, ident, declExpr, null, line, col); .)
";"
.

DeclIf<out StmtNode decl> =
SYNC
"if" (. int line = t.line; int col = t.col; .)
"(" Expr<out ExprNode expr> ")"
"then"
DeclBlock<out StmtNode thenDecl> (. decl = new StmtIfNode(expr, thenDecl, new StmtSkipNode(), line, col); .)
["else"
DeclBlock<out StmtNode elseDecl> (. decl = new StmtIfNode(expr, thenDecl, elseDecl, line, col); .)
]
.


/*-----------------------------------Declarative Expressions-----------------------------------*/
DeclExpr<out ExprNode declExpr> = (. declExpr = null; .)
( Text<out declExpr>
| Line<out declExpr>
| Curve<out declExpr>
| Place<out declExpr>
| Scale<out declExpr>
| Rotate<out declExpr> )
.

Text<out ExprNode declExpr> =
"text" (. int line = t.line; int col = t.col; .)
Expr<out ExprNode expr> (. declExpr = new ExprTextNode(expr, line, col); .)
.

Line<out ExprNode declExpr> = (. List<ExprNode> exprList = new ArrayList<>(); .)
"line" (. int line = t.line; int col = t.col; .)
"("
Expr<out ExprNode expr> (. exprList.add(expr); .)
","
Expr<out expr> (. exprList.add(expr); .)
")"
"to"
"("
Expr<out expr> (. exprList.add(expr); .)
","
Expr<out expr> (. exprList.add(expr); .)
")"
{
"to"
"("
Expr<out expr> (. exprList.add(expr); .)
","
Expr<out expr> (. exprList.add(expr); .)
")"
} (. declExpr = new ExprLineNode(exprList, line, col); .)
.

Curve<out ExprNode declExpr> = (. List<ExprNode> exprList = new ArrayList<>(); .)
"curve" (. int line = t.line; int col = t.col; .)
"("
Expr<out ExprNode expr> (. exprList.add(expr); .)
","
Expr<out expr> (. exprList.add(expr); .)
")"
"to"
"("
Expr<out expr> (. exprList.add(expr); .)
","
Expr<out expr> (. exprList.add(expr); .)
")"
"to"
"("
Expr<out expr> (. exprList.add(expr); .)
","
Expr<out expr> (. exprList.add(expr); .)
")"
{
"to"
"("
Expr<out expr> (. exprList.add(expr); .)
","
Expr<out expr> (. exprList.add(expr); .)
")"
"to"
"("
Expr<out expr> (. exprList.add(expr); .)
","
Expr<out expr> (. exprList.add(expr); .)
")"
} (. declExpr = new ExprCurveNode(exprList, line, col); .)
.

Place<out ExprNode declExpr> =
"place" (. int line = t.line; int col = t.col; .)
Expr<out ExprNode lExpr>
"at"
"("
Expr<out ExprNode mExpr>
","
Expr<out ExprNode rExpr>
")" (. declExpr = new ExprPlaceNode(lExpr, mExpr, rExpr, line, col); .)
.

Scale<out ExprNode declExpr> =
"scale" (. int line = t.line; int col = t.col; .)
Expr<out ExprNode lExpr>
"by" "(" Expr<out ExprNode mExpr> ","
Expr<out ExprNode rExpr> ","

")"
(. declExpr = new ExprScaleNode(lExpr, mExpr, rExpr, line, col); .)
.

Rotate<out ExprNode declExpr> =
"rotate" (. int line = t.line; int col = t.col; .)
Expr<out ExprNode fExpr>
"around"
"("Expr<out ExprNode sExpr> ","
Expr<out ExprNode tExpr>")"
"by"
Expr<out ExprNode lExpr> (. declExpr = new ExprRotateNode(fExpr, sExpr, tExpr, lExpr, line, col); .)
.

/*-----------------------------------Expressions-----------------------------------*/
Expr<out ExprNode expr> =
AndExpr<out expr>
{ "||" (. String op = t.val; int line = t.line; int col = t.col; .)
AndExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
}
.

AndExpr<out ExprNode expr> =
EqExpr<out expr>
{ "&&" (. String op = t.val; int line = t.line; int col = t.col; .)
EqExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
}
.

EqExpr<out ExprNode expr> =
RelExpr<out expr>
{ ( "==" | "!=") (. String op = t.val; int line = t.line; int col = t.col; .)
RelExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
}
.

RelExpr<out ExprNode expr> =
ConcatExpr<out expr>
{ ( "<=" | "<" | ">=" | ">" ) (. String op = t.val; int line = t.line; int col = t.col; .)
ConcatExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
}
.

ConcatExpr<out ExprNode expr> =
PlusExpr<out expr>
{ "++" (. String op = t.val; int line = t.line; int col = t.col; .)
PlusExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
}
.

PlusExpr<out ExprNode expr> =
MultExpr<out expr>
{ ( "+" | "-" ) (. String op = t.val; int line = t.line; int col = t.col; .)
MultExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
}
.

MultExpr<out ExprNode expr> =
NotExpr<out expr>
{ ( "*" | "/" ) (. String op = t.val; int line = t.line; int col = t.col; .)
NotExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
}
.

NotExpr<out ExprNode expr>          (. List<Character> unaries = new ArrayList(); int line = -1; int col = -1; .)
= { ( '!' (. unaries.add('!'); .)
| '-' (. unaries.add('-'); .) ) (. line = t.line; col = t.col; .)
} Term<out expr>    (. expr = makeUnOpExpr(unaries, expr, line, col);  .)
.

Term<out ExprNode expr> = (. expr = null; .)
(   IDENT (. String ident = t.val; int line = t.line; int col = t.col; .) (. expr = new ExprIdentifierNode(ident, line, col); .)
[ ( ExprListAccess<out expr, ident, line, col>
| ExprFuncCall<out expr, ident, line, col> ) ]
|   ExprListDeclaration<out expr>
|   INT     (. expr = new ExprIntNode(t.val, t.line, t.col); .)
|   DOUBLE  (. expr = new ExprDoubleNode(t.val, t.line, t.col); .)
|   STRING  (. expr = new ExprStringNode(t.val, t.line, t.col); .)
|   ( "true" | "false" )  (. expr = new ExprBoolNode(t.val, t.line, t.col); .)
|   "(" Expr<out expr> ")" )
.

ExprFuncCall<out ExprFunctionCallNode funcCall, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
"("
[Expr<out ExprNode arg> (. exprList.add(arg); .)
{ "," Expr<out arg> (. exprList.add(arg); .)
}]
")" (. funcCall = new ExprFunctionCallNode(ident, exprList, line, col); .)
.

ExprListAccess<out ExprNode expr, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
"["
Expr<out expr> (. exprList.add(expr); .)
"]"
{
"["
Expr<out expr> (. exprList.add(expr); .)
"]"
} (. expr = new ExprListAccessNode(ident, exprList, line, col); .)
.

ExprListDeclaration<out ExprNode expr> = (. List<ExprNode> exprs = new ArrayList<>(); .)
"[" (. int line = t.line; int col = t.col; .)
[ Expr<out expr> (. exprs.add(expr); .)
]
{ "," Expr<out expr> (. exprs.add(expr); .)
}
"]" (. expr = new ExprListDeclaration(exprs, line, col); .)
.

/*-----------------------------------Types-----------------------------------*/
DeclType<out TypeNode type> = (. type = null; .)
( "shape" (. type = new TypeShapeNode(t.line, t.col); .)
| Type<out type> )
.

FunctionType<out TypeNode type> = (. type = null; .)
( "void" (. type = new TypeVoidNode(t.line, t.col); .)
| Type<out type> )
.

Type<out TypeNode type> = (. type = null; .)
( "int" (. type = new TypeIntNode(t.line, t.col); .)
| "double" (. type = new TypeDoubleNode(t.line, t.col); .)
| "bool" (. type = new TypeBoolNode(t.line, t.col); .)
| "string" (. type = new TypeStringNode(t.line, t.col); .)
| "[" Type<out TypeNode innerType> "]" (. type = new TypeListNode(innerType, t.line, t.col); .) )
.

END Program . // Must refer to the same non-terminal as "COMPILER" at the top.

