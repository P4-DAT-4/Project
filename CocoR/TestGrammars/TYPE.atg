/* Imports here are inserted at the top of the generated lexer and parser. */
import afs.nodes.def.*;
import afs.nodes.event.*;
import afs.nodes.expr.*;
import afs.nodes.prog.*;
import afs.nodes.stmt.*;
import afs.nodes.type.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;

/* The required start of a Coco/R grammar file. "Program" specifies the starting symbol of the grammar. */
COMPILER Program
/* Code here is injected at the start of the parser class. */
/*-----------------------------------Helper functions-----------------------------------*/

    public TypeNode mainNode = null; // This contains the AST generated by calling parser.Parse().

    public boolean hasErrors() {
        return errors.count > 0;
    }

/*------------------------------------------------------------------------*/
/* The following section contains the token specification of AFS.*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  digit = "0123456789" .
  lf  = '\n' .

TOKENS
  INT = digit {digit} .
  DOUBLE = digit {digit} "." digit {digit} .
  STRING = '"' { letter | digit } '"' .
  IDENT  = ('_' | letter) {letter | digit | '_'} .

COMMENTS FROM "/*" TO "*/" NESTED  /* Nested means: "There can be comments inside comments" */
COMMENTS FROM "//" TO lf

IGNORE '\r' + '\n' + '\t' /* These characters are ignored by the lexer */

/*------------------------------------------------------------------------*/
/* The rest of the file contains the grammar for AFS.  */
PRODUCTIONS

Program = Type<out mainNode> .

/*-----------------------------------Types-----------------------------------*/
DeclType<out TypeNode type> = (. type = null; .)
    ( "shape" (. type = new TypeShapeNode(t.line, t.col); .)
    | Type<out type> )
.

FunctionType<out TypeNode type> = (. type = null; .)
    ( "void" (. type = new TypeVoidNode(t.line, t.col); .)
    | Type<out type> )
.

Type<out TypeNode type> = (. type = null; .)
    ( "int" (. type = new TypeIntNode(t.line, t.col); .)
    | "double" (. type = new TypeDoubleNode(t.line, t.col); .)
    | "bool" (. type = new TypeBoolNode(t.line, t.col); .)
    | "string" (. type = new TypeStringNode(t.line, t.col); .)
    | "[" Type<out TypeNode innerType> "]" (. type = new TypeListNode(innerType, t.line, t.col); .) )
.

END Program . // Must refer to the same non-terminal as "COMPILER" at the top.
