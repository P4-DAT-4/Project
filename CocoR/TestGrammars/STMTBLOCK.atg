/* Imports here are inserted at the top of the generated lexer and parser. */
import afs.nodes.def.*;
import afs.nodes.event.*;
import afs.nodes.expr.*;
import afs.nodes.prog.*;
import afs.nodes.stmt.*;
import afs.nodes.type.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;

/* The required start of a Coco/R grammar file. "Program" specifies the starting symbol of the grammar. */
COMPILER Program
/* Code here is injected at the start of the parser class. */
/*-----------------------------------Helper functions-----------------------------------*/

    public StmtNode mainNode = null; // This contains the AST generated by calling parser.Parse().

    public boolean hasErrors() {
        return errors.count > 0;
    }

    private StmtNode toCompStmt(List<StmtNode> stmts) {
        if (stmts.isEmpty()) {
            return new StmtSkipNode();
        }
        StmtNode left = stmts.getFirst();

        if (stmts.size() == 1) {
            return left;
        } else {
            int line = left.getLineNumber();
            int col = left.getColumnNumber();
            List<StmtNode> rest = stmts.subList(1, stmts.size());
            StmtNode right = toCompStmt(rest);
            if (left instanceof StmtDeclarationNode) {
                return new StmtDeclarationNode(((StmtDeclarationNode) left).getType(),
                                               ((StmtDeclarationNode) left).getIdentifier(),
                                               ((StmtDeclarationNode) left).getExpression(),
                                               right, line, col);
            } else {
                return new StmtCompositionNode(left, right, line, col);
            }
        }
    }

    private ExprNode makeUnOpExpr(List<Character> unaries, ExprNode base, int line, int col) {
        ExprNode result = base;
        int index = 0;
        while (index < unaries.size()) {
            char ch = unaries.get(index);
            result = switch (ch) {
                case '!' -> new ExprUnopNode(result, UnOp.NOT, line, col);
                case '-' -> new ExprUnopNode(result, UnOp.NEG, line, col);
                default -> throw new FatalError("Unknown unary operator: " + ch);
            };
            index++;
        }
        return result;
    }

    private ExprNode makeBinOpExpr(ExprNode left, String op, ExprNode right, int line, int column) {
        return switch (op) {
            case "*" -> new ExprBinopNode(left, BinOp.MUL, right, line, column);
            case "/" -> new ExprBinopNode(left, BinOp.DIV, right, line, column);
            case "+" -> new ExprBinopNode(left, BinOp.ADD, right, line, column);
            case "-" -> new ExprBinopNode(left, BinOp.SUB, right, line, column);
            case "++" -> new ExprBinopNode(left, BinOp.CONCAT, right, line, column);
            case "<=" -> {  ExprNode equals = makeBinOpExpr(left, "==", right, line, column);
                            ExprNode lessThan = makeBinOpExpr(left, "<", right, line, column);
                            yield makeBinOpExpr(equals, "||", lessThan, line, column);
            }
            case ">=" -> {  ExprNode equals = makeBinOpExpr(left, "==", right, line, column);
                            ExprNode lessThan = makeBinOpExpr(left, ">", right, line, column);
                            yield makeBinOpExpr(equals, "||", lessThan, line, column);
            }
            case "<" -> new ExprBinopNode(left, BinOp.LT, right, line, column);
            case ">" -> new ExprBinopNode(right, BinOp.LT, left, line, column);
            case "==" -> new ExprBinopNode(left, BinOp.EQ, right, line, column);
            case "!=" -> {  ExprNode equal = makeBinOpExpr(left, "==", right, line, column);
                            yield new ExprUnopNode(equal, UnOp.NOT, line, column);
            }
            case "&&" -> new ExprBinopNode(left, BinOp.AND, right, line, column);
            case "||" -> {  ExprNode notLeftExpr = new ExprUnopNode(left, UnOp.NOT, line, column);
                            ExprNode notRightExpr = new ExprUnopNode(right, UnOp.NOT, line, column);
                            ExprNode andNode = makeBinOpExpr(notLeftExpr, "&&", notRightExpr, line, column);
                            yield new ExprUnopNode(andNode, UnOp.NOT, line, column);
            }
            default -> throw new FatalError("Unknown binary operator: " + op);
        };
    }

/*------------------------------------------------------------------------*/
/* The following section contains the token specification of AFS.*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  digit = "0123456789" .
  lf  = '\n' .

TOKENS
  INT = digit {digit} .
  DOUBLE = digit {digit} "." digit {digit} .
  STRING = '"' { letter | digit } '"' .
  IDENT  = ('_' | letter) {letter | digit | '_'} .

COMMENTS FROM "/*" TO "*/" NESTED  /* Nested means: "There can be comments inside comments" */
COMMENTS FROM "//" TO lf

IGNORE '\r' + '\n' + '\t' /* These characters are ignored by the lexer */

/*------------------------------------------------------------------------*/
/* The rest of the file contains the grammar for AFS.  */
PRODUCTIONS

Program = StmtBlock<out mainNode> .

/*-----------------------------------Statements-----------------------------------*/
StmtBlock<out StmtNode stmt> = (. List<StmtNode> stmts = new ArrayList<>(); .)
    "{"
    { Stmt<out StmtNode innerStmt> (. stmts.add(innerStmt); .)
    }
    "}" (. stmt = toCompStmt(stmts); .)
.

Stmt<out StmtNode stmt> = (. stmt = new StmtSkipNode(); .)
    ( StmtDeclaration<out stmt>
    | StmtIf<out stmt>
    | StmtWhile<out stmt>
    | StmtReturn<out stmt>
    | IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
        ( StmtAssignment<out stmt, ident, line, col>
        | StmtListAssignment<out stmt, ident, line, col>
        | StmtFuncCall<out stmt, ident, line, col> )
    )
.

StmtDeclaration<out StmtNode stmt> =
    Type<out TypeNode type>
    IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
    "="
    Expr<out ExprNode expr> (. stmt = new StmtDeclarationNode(type, ident, expr, new StmtSkipNode(), line, col); .)
    ";"
.

StmtAssignment<out StmtNode stmt, String ident, int line, int col> =
    "="
    Expr<out ExprNode expr> (.
        stmt = new StmtAssignmentNode(ident, expr, line, col); .)
    ";"
.

StmtListAssignment<out StmtNode stmt, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "["
    Expr<out ExprNode expr> (. exprList.add(expr); .)
    "]"
    {
    "["
    Expr<out expr> (. exprList.add(expr); .)
    "]"
    }
    "="
    Expr<out expr> (. stmt = new StmtListAssignmentNode(ident, exprList, expr, line, col); .)
    ";"
.

StmtIf<out StmtNode stmt> =
    SYNC
    "if" (. int line = t.line; int col = t.col; .)
    "(" Expr<out ExprNode expr> ")"
    "then"
    StmtBlock<out StmtNode thenStmt> (. stmt = new StmtIfNode(expr, thenStmt, new StmtSkipNode(), line, col); .)
    ["else"
    StmtBlock<out StmtNode elseStmt> (. stmt = new StmtIfNode(expr, thenStmt, elseStmt, line, col); .)
    ]
.

StmtWhile<out StmtNode stmt> =
    SYNC
    "while" (. int line = t.line; int col = t.col; .)
    "(" Expr<out ExprNode expr>
    ")"
    "do"
    StmtBlock<out StmtNode whlStmt> (. stmt = new StmtWhileNode(expr, whlStmt, line, col); .)
.

StmtReturn<out StmtNode stmt> =
    "return" (. int line = t.line; int col = t.col; .)
    Expr<out ExprNode expr> (. stmt = new StmtReturnNode(expr, line, col); .)
    ";"
.

StmtFuncCall<out StmtNode stmt, String ident, int line, int col> = (. List<ExprNode> arguments = new ArrayList<>(); .)
    "("
    [Expr<out ExprNode arg> (. arguments.add(arg); .)
    { "," Expr<out arg> (. arguments.add(arg); .)
    }]
    ")"
    ";" (. stmt = new StmtFunctionCallNode(ident, arguments, t.line, t.col); .)
.

/*-----------------------------------Expressions-----------------------------------*/
Expr<out ExprNode expr> =
    AndExpr<out expr>
    { "||" (. String op = t.val; int line = t.line; int col = t.col; .)
    AndExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

AndExpr<out ExprNode expr> =
    EqExpr<out expr>
    { "&&" (. String op = t.val; int line = t.line; int col = t.col; .)
    EqExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

EqExpr<out ExprNode expr> =
    RelExpr<out expr>
    { ( "==" | "!=") (. String op = t.val; int line = t.line; int col = t.col; .)
    RelExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

RelExpr<out ExprNode expr> =
    ConcatExpr<out expr>
    { ( "<=" | "<" | ">=" | ">" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    ConcatExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

ConcatExpr<out ExprNode expr> =
    PlusExpr<out expr>
    { "++" (. String op = t.val; int line = t.line; int col = t.col; .)
    PlusExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

PlusExpr<out ExprNode expr> =
    MultExpr<out expr>
    { ( "+" | "-" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    MultExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

MultExpr<out ExprNode expr> =
    NotExpr<out expr>
    { ( "*" | "/" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    NotExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

NotExpr<out ExprNode expr>          (. List<Character> unaries = new ArrayList(); int line = -1; int col = -1; .)
    = { ( '!' (. unaries.add('!'); .)
        | '-' (. unaries.add('-'); .) ) (. line = t.line; col = t.col; .)
      } Term<out expr>    (. expr = makeUnOpExpr(unaries, expr, line, col);  .)
.

Term<out ExprNode expr> = (. expr = null; .)
    (   IDENT (. String ident = t.val; int line = t.line; int col = t.col; .) (. expr = new ExprIdentifierNode(ident, line, col); .)
        [ ( ExprListAccess<out expr, ident, line, col>
          | ExprFuncCall<out expr, ident, line, col> ) ]
    |   ExprListDeclaration<out expr>
    |   INT     (. expr = new ExprIntNode(t.val, t.line, t.col); .)
    |   DOUBLE  (. expr = new ExprDoubleNode(t.val, t.line, t.col); .)
    |   STRING  (. expr = new ExprStringNode(t.val, t.line, t.col); .)
    |   ( "true" | "false" )  (. expr = new ExprBoolNode(t.val, t.line, t.col); .)
    |   "(" Expr<out expr> ")" )
.

ExprFuncCall<out ExprFunctionCallNode funcCall, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "("
    [Expr<out ExprNode arg> (. exprList.add(arg); .)
    { "," Expr<out arg> (. exprList.add(arg); .)
    }]
    ")" (. funcCall = new ExprFunctionCallNode(ident, exprList, line, col); .)
.

ExprListAccess<out ExprNode expr, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "["
    Expr<out expr> (. exprList.add(expr); .)
    "]"
    {
    "["
    Expr<out expr> (. exprList.add(expr); .)
    "]"
    } (. expr = new ExprListAccessNode(ident, exprList, line, col); .)
.

ExprListDeclaration<out ExprNode expr> = (. List<ExprNode> exprs = new ArrayList<>(); .)
    "[" (. int line = t.line; int col = t.col; .)
    [ Expr<out expr> (. exprs.add(expr); .)
    ]
    { "," Expr<out expr> (. exprs.add(expr); .)
    }
    "]" (. expr = new ExprListDeclaration(exprs, line, col); .)
.

/*-----------------------------------Types-----------------------------------*/
DeclType<out TypeNode type> = (. type = null; .)
    ( "shape" (. type = new TypeShapeNode(t.line, t.col); .)
    | Type<out type> )
.

FunctionType<out TypeNode type> = (. type = null; .)
    ( "void" (. type = new TypeVoidNode(t.line, t.col); .)
    | Type<out type> )
.

Type<out TypeNode type> = (. type = null; .)
    ( "int" (. type = new TypeIntNode(t.line, t.col); .)
    | "double" (. type = new TypeDoubleNode(t.line, t.col); .)
    | "bool" (. type = new TypeBoolNode(t.line, t.col); .)
    | "string" (. type = new TypeStringNode(t.line, t.col); .)
    | "[" Type<out TypeNode innerType> "]" (. type = new TypeListNode(innerType, t.line, t.col); .) )
.

END Program . // Must refer to the same non-terminal as "COMPILER" at the top.
