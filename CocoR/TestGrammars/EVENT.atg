/* Imports here are inserted at the top of the generated lexer and parser. */
import afs.nodes.def.*;
import afs.nodes.event.*;
import afs.nodes.expr.*;
import afs.nodes.prog.*;
import afs.nodes.stmt.*;
import afs.nodes.type.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;

/* The required start of a Coco/R grammar file. "Program" specifies the starting symbol of the grammar. */
COMPILER Program
/* Code here is injected at the start of the parser class. */
/*-----------------------------------Helper functions-----------------------------------*/

    public EventNode mainNode = null; // This contains the AST generated by calling parser.Parse().

    public boolean hasErrors() {
        return errors.count > 0;
    }

    private EventNode toCompEvent(List<EventNode> events) {
        if (events.isEmpty()) {
            throw new FatalError("Empty events list");
        }
        EventNode left = events.getFirst();

        if (events.size() == 1) {
            return left;
        } else {
            int line = left.getLineNumber();
            int col = left.getColumnNumber();
            List<EventNode> rest = events.subList(1, events.size());
            EventNode right = toCompEvent(rest);
            return new EventCompositionNode(left, right, line, col);
        }
    }

    private ExprNode makeUnOpExpr(List<Character> unaries, ExprNode base, int line, int col) {
        ExprNode result = base;
        int index = 0;
        while (index < unaries.size()) {
            char ch = unaries.get(index);
            result = switch (ch) {
                case '!' -> new ExprUnopNode(result, UnOp.NOT, line, col);
                case '-' -> new ExprUnopNode(result, UnOp.NEG, line, col);
                default -> throw new FatalError("Unknown unary operator: " + ch);
            };
            index++;
        }
        return result;
    }

    private ExprNode makeBinOpExpr(ExprNode left, String op, ExprNode right, int line, int column) {
        return switch (op) {
            case "*" -> new ExprBinopNode(left, BinOp.MUL, right, line, column);
            case "/" -> new ExprBinopNode(left, BinOp.DIV, right, line, column);
            case "+" -> new ExprBinopNode(left, BinOp.ADD, right, line, column);
            case "-" -> new ExprBinopNode(left, BinOp.SUB, right, line, column);
            case "++" -> new ExprBinopNode(left, BinOp.CONCAT, right, line, column);
            case "<=" -> {  ExprNode equals = makeBinOpExpr(left, "==", right, line, column);
                            ExprNode lessThan = makeBinOpExpr(left, "<", right, line, column);
                            yield makeBinOpExpr(equals, "||", lessThan, line, column);
            }
            case ">=" -> {  ExprNode equals = makeBinOpExpr(left, "==", right, line, column);
                            ExprNode lessThan = makeBinOpExpr(left, ">", right, line, column);
                            yield makeBinOpExpr(equals, "||", lessThan, line, column);
            }
            case "<" -> new ExprBinopNode(left, BinOp.LT, right, line, column);
            case ">" -> new ExprBinopNode(right, BinOp.LT, left, line, column);
            case "==" -> new ExprBinopNode(left, BinOp.EQ, right, line, column);
            case "!=" -> {  ExprNode equal = makeBinOpExpr(left, "==", right, line, column);
                            yield new ExprUnopNode(equal, UnOp.NOT, line, column);
            }
            case "&&" -> new ExprBinopNode(left, BinOp.AND, right, line, column);
            case "||" -> {  ExprNode notLeftExpr = new ExprUnopNode(left, UnOp.NOT, line, column);
                            ExprNode notRightExpr = new ExprUnopNode(right, UnOp.NOT, line, column);
                            ExprNode andNode = makeBinOpExpr(notLeftExpr, "&&", notRightExpr, line, column);
                            yield new ExprUnopNode(andNode, UnOp.NOT, line, column);
            }
            default -> throw new FatalError("Unknown binary operator: " + op);
        };
    }

/*------------------------------------------------------------------------*/
/* The following section contains the token specification of AFS.*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  digit = "0123456789" .
  lf  = '\n' .

TOKENS
  INT = digit {digit} .
  DOUBLE = digit {digit} "." digit {digit} .
  STRING = '"' { letter | digit } '"' .
  IDENT  = ('_' | letter) {letter | digit | '_'} .

COMMENTS FROM "/*" TO "*/" NESTED  /* Nested means: "There can be comments inside comments" */
COMMENTS FROM "//" TO lf

IGNORE '\r' + '\n' + '\t' /* These characters are ignored by the lexer */

/*------------------------------------------------------------------------*/
/* The rest of the file contains the grammar for AFS.  */
PRODUCTIONS

Program = Events<out mainNode> .

/*-----------------------------------Events-----------------------------------*/
Events<out EventNode event> = (. List<EventNode> events = new ArrayList<>(); List<ExprNode> arguments = new ArrayList<>(); String ident, fname; .)
    IDENT (. ident = t.val; .)
    "do"
    IDENT (. int line = t.line; int col = t.col; fname = t.val; .)
    "("
    [Expr<out ExprNode arg> (. arguments.add(arg); .)
    { "," Expr<out arg> (. arguments.add(arg); .)
    }]
    ")"
    ";" (. event = new EventDeclarationNode(ident, fname, arguments, line, col); events.add(event); .)
    {
    IDENT (. line = t.line; col = t.col; ident = t.val; arguments = new ArrayList<>(); .)
    "do"
    IDENT (. line = t.line; col = t.col; fname = t.val; .)
    "("
    [Expr<out ExprNode arg> (. arguments.add(arg); .)
    { "," Expr<out arg> (. arguments.add(arg); .)
    }]
    ")"
    ";" (. event = new EventDeclarationNode(ident, fname, arguments, line, col); events.add(event); .)
    } (. event = toCompEvent(events); .)
.

/*-----------------------------------Expressions-----------------------------------*/
Expr<out ExprNode expr> =
    AndExpr<out expr>
    { "||" (. String op = t.val; int line = t.line; int col = t.col; .)
    AndExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

AndExpr<out ExprNode expr> =
    EqExpr<out expr>
    { "&&" (. String op = t.val; int line = t.line; int col = t.col; .)
    EqExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

EqExpr<out ExprNode expr> =
    RelExpr<out expr>
    { ( "==" | "!=") (. String op = t.val; int line = t.line; int col = t.col; .)
    RelExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

RelExpr<out ExprNode expr> =
    ConcatExpr<out expr>
    { ( "<=" | "<" | ">=" | ">" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    ConcatExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

ConcatExpr<out ExprNode expr> =
    PlusExpr<out expr>
    { "++" (. String op = t.val; int line = t.line; int col = t.col; .)
    PlusExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

PlusExpr<out ExprNode expr> =
    MultExpr<out expr>
    { ( "+" | "-" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    MultExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

MultExpr<out ExprNode expr> =
    NotExpr<out expr>
    { ( "*" | "/" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    NotExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

NotExpr<out ExprNode expr>          (. List<Character> unaries = new ArrayList(); int line = -1; int col = -1; .)
    = { ( '!' (. unaries.add('!'); .)
        | '-' (. unaries.add('-'); .) ) (. line = t.line; col = t.col; .)
      } Term<out expr>    (. expr = makeUnOpExpr(unaries, expr, line, col);  .)
.

Term<out ExprNode expr> = (. expr = null; .)
    (   IDENT (. String ident = t.val; int line = t.line; int col = t.col; .) (. expr = new ExprIdentifierNode(ident, line, col); .)
        [ ( ExprListAccess<out expr, ident, line, col>
          | ExprFuncCall<out expr, ident, line, col> ) ]
    |   ExprListDeclaration<out expr>
    |   INT     (. expr = new ExprIntNode(t.val, t.line, t.col); .)
    |   DOUBLE  (. expr = new ExprDoubleNode(t.val, t.line, t.col); .)
    |   STRING  (. expr = new ExprStringNode(t.val, t.line, t.col); .)
    |   ( "true" | "false" )  (. expr = new ExprBoolNode(t.val, t.line, t.col); .)
    |   "(" Expr<out expr> ")" )
.

ExprFuncCall<out ExprFunctionCallNode funcCall, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "("
    [Expr<out ExprNode arg> (. exprList.add(arg); .)
    { "," Expr<out arg> (. exprList.add(arg); .)
    }]
    ")" (. funcCall = new ExprFunctionCallNode(ident, exprList, line, col); .)
.

ExprListAccess<out ExprNode expr, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "["
    Expr<out expr> (. exprList.add(expr); .)
    "]"
    {
    "["
    Expr<out expr> (. exprList.add(expr); .)
    "]"
    } (. expr = new ExprListAccessNode(ident, exprList, line, col); .)
.

ExprListDeclaration<out ExprNode expr> = (. List<ExprNode> exprs = new ArrayList<>(); .)
    "[" (. int line = t.line; int col = t.col; .)
    [ Expr<out expr> (. exprs.add(expr); .)
    ]
    { "," Expr<out expr> (. exprs.add(expr); .)
    }
    "]" (. expr = new ExprListDeclaration(exprs, line, col); .)
.

END Program . // Must refer to the same non-terminal as "COMPILER" at the top.
