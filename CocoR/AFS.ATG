/* This file contains the Token specification and Grammar which COCO/R uses to construct the scanner
and parser. COCO/R uses Extend Bacus-Naur form (EBNF) for the grammar, as well as its own series of commands
which will be explained when met first in context.  */

// The scanner/lexer and parser files are created by inserting generated code (based on this .ATG file)
// into the "Scanner.frame" and "Parser.frame" files located alongside the AFS.ATG file.

/* The EBNF uses the following extensions: */
/* [] Brackets mean that the string is written zero or one times.  */
/* {} Curly brackets mean that the string is repeated zero or more times  */
/* () is a grouping used alongside |. The parenthesis contains a series of strings separated by |. This means that exactly one of the strings is chosen. */

/* Imports here are inserted at the top of the generated lexer and parser. */
import afs.nodes.def.*;
import afs.nodes.event.*;
import afs.nodes.expr.*;
import afs.nodes.prog.*;
import afs.nodes.stmt.*;
import afs.nodes.type.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;

/* The required start of a Coco/R grammar file. "Program" specifies the starting symbol of the grammar. */
COMPILER Program
/* Code here is injected at the start of the parser class. */
    public ProgNode mainNode = null; // This contains the AST generated by calling parser.Parse().

    public boolean hasErrors() {
        return errors.count > 0;
    }

    private EventNode toCompEvent(List<EventNode> eventsReversed) {
        if (eventsReversed.isEmpty()) {
            throw new RuntimeException("Empty events list");
        }
        EventNode left = eventsReversed.getFirst();

        if (eventsReversed.size() == 1) {
            return left;
        } else {
            int line = left.getLineNumber();
            int col = left.getColumnNumber();
            List<EventNode> rest = eventsReversed.subList(1, eventsReversed.size());
            EventNode right = toCompEvent(rest);
            return new EventCompositionNode(left, right, line, col);
        }
    }

    private StmtNode toCompStmt(List<StmtNode> stmtsReversed) {
        if (stmtsReversed.isEmpty()) {
            return new StmtSkipNode();
        }
        StmtNode left = stmtsReversed.getFirst();

        if (stmtsReversed.size() == 1) {
            if (left instanceof StmtDeclarationNode) {
                return new StmtDeclarationNode(((StmtDeclarationNode) left).getType(), ((StmtDeclarationNode) left).getIdentifier(), ((StmtDeclarationNode) left).getExpression(), new StmtSkipNode(), left.getLineNumber(), left.getColumnNumber());
            } else {
                return left;
            }
        } else {
            int line = left.getLineNumber();
            int col = left.getColumnNumber();
            List<StmtNode> rest = stmtsReversed.subList(1, stmtsReversed.size());
            StmtNode right = toCompStmt(rest);
            if (left instanceof StmtDeclarationNode) {
                return new StmtDeclarationNode(((StmtDeclarationNode) left).getType(), ((StmtDeclarationNode) left).getIdentifier(), ((StmtDeclarationNode) left).getExpression(), new StmtSkipNode(), line, col);
            } else {
                return new StmtCompositionNode(left, right, line, col);
            }
        }
    }

    private ExprNode makeUnOpExpr(List<Character> unaries, ExprNode base, int line, int col) {
        ExprNode result = base;
        int index = 0;
        while (index < unaries.size()) {
            char ch = unaries.get(index);
            result = switch (ch) {
                case '!' -> new ExprUnopNode(result, UnOp.NOT, line, col);
                case '-' -> new ExprUnopNode(result, UnOp.NEG, line, col);
                default -> throw new RuntimeException("Unknown unary operator: " + ch);
            };
            index++;
        }
        return result;
    }

    private ExprNode makeBinOpExpr(ExprNode left, String op, ExprNode right, int line, int column) {
        return switch (op) {
            case "*" -> new ExprBinopNode(left, BinOp.MUL, right, line, column);
            case "/" -> new ExprBinopNode(left, BinOp.DIV, right, line, column);
            case "+" -> new ExprBinopNode(left, BinOp.ADD, right, line, column);
            case "-" -> new ExprBinopNode(left, BinOp.SUB, right, line, column);
            case "++" -> new ExprBinopNode(left, BinOp.CONCAT, right, line, column);
            case "<=" -> {  ExprNode equals = makeBinOpExpr(left, "==", right, line, column);
                            ExprNode lessThan = makeBinOpExpr(left, "<", right, line, column);
                            yield makeBinOpExpr(equals, "||", lessThan, line, column);
            }
            case ">=" -> {  ExprNode equals = makeBinOpExpr(left, "==", right, line, column);
                            ExprNode lessThan = makeBinOpExpr(left, ">", right, line, column);
                            yield makeBinOpExpr(equals, "||", lessThan, line, column);
            }
            case "<" -> new ExprBinopNode(left, BinOp.LT, right, line, column);
            case ">" -> new ExprBinopNode(right, BinOp.LT, left, line, column);
            case "==" -> new ExprBinopNode(left, BinOp.EQ, right, line, column);
            case "!=" -> {  ExprNode equal = makeBinOpExpr(left, "==", right, line, column);
                            yield new ExprUnopNode(equal, UnOp.NOT, line, column);
            }
            case "&&" -> new ExprBinopNode(left, BinOp.AND, right, line, column);
            case "||" -> {  ExprNode notLeftExpr = new ExprUnopNode(left, UnOp.NOT, line, column);
                            ExprNode notRightExpr = new ExprUnopNode(right, UnOp.NOT, line, column);
                            ExprNode andNode = makeBinOpExpr(notLeftExpr, "&&", notRightExpr, line, column);
                            yield new ExprUnopNode(andNode, UnOp.NOT, line, column);
            }
            default -> throw new RuntimeException("Unknown binary operator: " + op);
        };
    }

    private List<ExprNode> coordsToList(List<ExprListDeclaration> coords) {
        List<ExprNode> exprs = new ArrayList<>();
        for (ExprListDeclaration coord : coords) {
            exprs.addAll(coord.getExpressions());
        }
        return exprs;
    }
/*------------------------------------------------------------------------*/
/* The following section contains the token specification of AFS.*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  digit = "0123456789" .
  lf  = '\n' .

TOKENS
  INT = digit {digit} .
  DOUBLE = digit {digit} "." digit {digit} .
  STRING = '"' { letter | digit } '"' .
  IDENT  = ('_' | letter) {letter | digit | '_'} .

COMMENTS FROM "/*" TO "*/" NESTED  /* Nested means: "There can be comments inside comments" */
COMMENTS FROM "//" TO lf

IGNORE '\r' + '\n' + '\t' /* These characters are ignored by the lexer */

/*------------------------------------------------------------------------*/
/* The rest of the file contains the grammar for AFS.  */
PRODUCTIONS

Program = Prog<out mainNode>
.

/*------------------------------------------------------------------------*/
Prog<out ProgNode prog> = (. ArrayList<DefNode> defList = new ArrayList(); .)
    { Def<out DefNode def> (. defList.add(def); .) }
    Visualize<out DefNode vis> (. defList.add(vis); prog = new ProgNode(defList); .)
.

/*-----------------------------------Visualize-----------------------------------*/
Visualize<out DefNode vis> = (. List<ExprNode> arguments = new ArrayList<>(); .)
    "visualize" (. int line = t.line; int col = t.col; .)
    IDENT (. String ident = t.val; .)
    "("
    [Expr<out ExprNode arg> (. arguments.add(arg); .)
    { "," Expr<out arg> (. arguments.add(arg); .)
    }]
    ")"
    ":"
    Events<out EventNode event> (. vis = new DefVisualizeNode(ident, arguments, event, line, col); .)
.

/*-----------------------------------Events-----------------------------------*/
Events<out EventNode event> = (. List<EventNode> events = new ArrayList<>(); List<ExprNode> arguments = new ArrayList<>(); .)
    Expr<out ExprNode expr>
    "do"
    IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
    "("
    [Expr<out ExprNode arg> (. arguments.add(arg); .)
    { "," Expr<out arg> (. arguments.add(arg); .)
    }]
    ")"
    ";" (. event = new EventDeclarationNode(expr, ident, arguments, line, col); events.add(event); .)
    { Expr<out expr> (. line = t.line; col = t.col; arguments = new ArrayList<>(); .)
    "do"
    IDENT (. line = t.line; col = t.col; ident = t.val; .)
    "("
    [Expr<out ExprNode arg> (. arguments.add(arg); .)
    { "," Expr<out arg> (. arguments.add(arg); .)
    }]
    ")"
    ";" (. event = new EventDeclarationNode(expr, ident, arguments, line, col); events.add(event); .)
    } (. event = toCompEvent(events); .)
.

/*-----------------------------------Definitions-----------------------------------*/
Def<out DefNode def> = (. def = null; .)
    SYNC
    ( FnDef<out def>
    | ImgDef<out def>
    | VarDef<out def> )
.

FnDef<out DefNode func> = (. List<Param> params = new ArrayList<>(); .)
    "fn" Type<out TypeNode type>
    IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
    "("
    [Param<out Param param> (. params.add(param); .)
    {"," Param<out param> (. params.add(param); .)
    }]
    ")"
    StmtBlock<out StmtNode stmt> (. func = new DefFunctionNode(type, ident, params, stmt, line, col); .)
.

ImgDef<out DefNode img> = (. List<Param> params = new ArrayList<>(); .)
    "img"
    IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
    "("
    [Param<out Param param> (. params.add(param); .)
    {"," Param<out param> (. params.add(param); .)
    }]
    ")"
    DeclBlock<out StmtNode decl> (. img = new DefFunctionNode(new TypeShapeNode(line, col), ident, params, decl, line, col); .)
.

Param<out Param param> =
    Type<out TypeNode type>
    IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
    (. param = new Param(type, ident, line, col); .)
.

VarDef<out DefNode def> =
    Type<out TypeNode type>
    IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
    "="
    Expr<out ExprNode expr> (. def = new DefDeclarationNode(type, ident, expr, line, col); .)
    ";"
.

/*-----------------------------------Statements-----------------------------------*/
StmtBlock<out StmtNode stmt> = (. List<StmtNode> stmts = new ArrayList<>(); .)
    "{"
    { Stmt<out StmtNode innerStmt> (. stmts.add(innerStmt); .)
    }
    "}" (. stmt = toCompStmt(stmts); .)
.

Stmt<out StmtNode stmt> = (. stmt = new StmtSkipNode(); .)
    ( StmtDeclaration<out stmt>
    | StmtIf<out stmt>
    | StmtWhile<out stmt>
    | StmtReturn<out stmt>
    | IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
        ( StmtAssignment<out stmt, ident, line, col>
        | StmtListAssignment<out stmt, ident, line, col>
        | StmtFuncCall<out stmt, ident, line, col> )
    )
.

StmtDeclaration<out StmtNode stmt> =
    Type<out TypeNode type>
    IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
    "="
    Expr<out ExprNode expr> (. stmt = new StmtDeclarationNode(type, ident, expr, null, line, col); .)
    ";"
.

StmtAssignment<out StmtNode stmt, String ident, int line, int col> =
    "="
    Expr<out ExprNode expr> (.
        stmt = new StmtAssignmentNode(ident, expr, line, col); .)
    ";"
.

StmtListAssignment<out StmtNode stmt, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "["
    Expr<out ExprNode expr> (. exprList.add(expr); .)
    "]"
    {
    "["
    Expr<out expr> (. exprList.add(expr); .)
    "]"
    }
    "="
    Expr<out expr> (. stmt = new StmtListAssignmentNode(ident, exprList, expr, line, col); .)
    ";"
.

StmtIf<out StmtNode stmt> =
    SYNC
    "if" (. int line = t.line; int col = t.col; .)
    "(" Expr<out ExprNode expr> ")"
    "then"
    StmtBlock<out StmtNode thenStmt> (. stmt = new StmtIfNode(expr, thenStmt, new StmtSkipNode(), line, col); .)
    ["else"
    StmtBlock<out StmtNode elseStmt> (. stmt = new StmtIfNode(expr, thenStmt, elseStmt, line, col); .)
    ]
.

StmtWhile<out StmtNode stmt> =
    SYNC
    "while" (. int line = t.line; int col = t.col; .)
    "(" Expr<out ExprNode expr>
    ")"
    "do"
    StmtBlock<out StmtNode whlStmt> (. stmt = new StmtWhileNode(expr, whlStmt, line, col); .)
.

StmtReturn<out StmtNode stmt> =
    "return" (. int line = t.line; int col = t.col; .)
    Expr<out ExprNode expr> (. stmt = new StmtReturnNode(expr, line, col); .)
    ";"
.

StmtFuncCall<out StmtNode stmt, String ident, int line, int col> = (. List<ExprNode> arguments = new ArrayList<>(); .)
    "("
    [Expr<out ExprNode arg> (. arguments.add(arg); .)
    { "," Expr<out arg> (. arguments.add(arg); .)
    }]
    ")"
    ";" (. stmt = new StmtFunctionCallNode(ident, arguments, t.line, t.col); .)
.

/*-----------------------------------Declarations-----------------------------------*/
DeclBlock<out StmtNode stmt> = (. List<StmtNode> decls = new ArrayList<>(); .)
    "{"
    { Decl<out StmtNode decl> (. decls.add(decl); .)
    }
    "}" (. stmt = toCompStmt(decls); .)
.

Decl<out StmtNode decl> = (. decl = new StmtSkipNode(); .)
    ( DeclDecl<out decl>
    | DeclIf<out decl> )
.

DeclDecl<out StmtNode decl> =
    DeclType<out TypeNode type>
    IDENT (. int line = t.line; int col = t.col; String ident = t.val; .)
    "="
    DeclExpr<out ExprNode declExpr> (. decl = new StmtDeclarationNode(type, ident, declExpr, null, line, col); .)
    ";"
.

DeclIf<out StmtNode decl> =
    SYNC
    "if" (. int line = t.line; int col = t.col; .)
    "(" Expr<out ExprNode expr> ")"
    "then"
    DeclBlock<out StmtNode thenDecl> (. decl = new StmtIfNode(expr, thenDecl, new StmtSkipNode(), line, col); .)
    ["else"
    DeclBlock<out StmtNode elseDecl> (. decl = new StmtIfNode(expr, thenDecl, elseDecl, line, col); .)
    ]
.

/*-----------------------------------Declarative Expressions-----------------------------------*/
DeclExpr<out ExprNode declExpr> = (. declExpr = null; .)
    ( Text<out declExpr>
    | Line<out declExpr>
    | Curve<out declExpr>
    | Place<out declExpr>
    | Scale<out declExpr>
    | Rotate<out declExpr>
    | Expr<out declExpr> )
.

Text<out ExprNode declExpr> =
    "text" (. int line = t.line; int col = t.col; .)
    Expr<out ExprNode expr> (. declExpr = new ExprTextNode(expr, line, col); .)
.

Line<out ExprNode declExpr> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "line" (. int line = t.line; int col = t.col; .)
    "("
    Expr<out ExprNode expr> (. exprList.add(expr); .)
    ","
    Expr<out expr> (. exprList.add(expr); .)
    ")"
    "to"
    "("
    Expr<out expr> (. exprList.add(expr); .)
    ","
    Expr<out expr> (. exprList.add(expr); .)
    ")"
    {
    "to"
    "("
    Expr<out expr> (. exprList.add(expr); .)
    ","
    Expr<out expr> (. exprList.add(expr); .)
    ")"
    } (. declExpr = new ExprLineNode(exprList, line, col); .)
.

Curve<out ExprNode declExpr> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "curve" (. int line = t.line; int col = t.col; .)"("
    "("
    Expr<out ExprNode expr> (. exprList.add(expr); .)
    ","
    Expr<out expr> (. exprList.add(expr); .)
    ")"
    "to"
    "("
    Expr<out expr> (. exprList.add(expr); .)
    ","
    Expr<out expr> (. exprList.add(expr); .)
    ")"
    "to"
    "("
    Expr<out expr> (. exprList.add(expr); .)
    ","
    Expr<out expr> (. exprList.add(expr); .)
    ")"
    {
    "to"
    "("
    Expr<out expr> (. exprList.add(expr); .)
    ","
    Expr<out expr> (. exprList.add(expr); .)
    ")"
    "to"
    "("
    Expr<out expr> (. exprList.add(expr); .)
    ","
    Expr<out expr> (. exprList.add(expr); .)
    ")"
    } (. declExpr = new ExprCurveNode(exprList, line, col); .)
.

Place<out ExprNode declExpr> =
    "place" (. int line = t.line; int col = t.col; .)
    Expr<out ExprNode lExpr>
    "at"
    "("
    Expr<out ExprNode mExpr>
    ","
    Expr<out ExprNode rExpr>
    ")" (. declExpr = new ExprPlaceNode(lExpr, mExpr, rExpr, line, col); .)
.

Scale<out ExprNode declExpr> =
    "scale" (. int line = t.line; int col = t.col; .)
    Expr<out ExprNode lExpr>
    "by"
    Expr<out ExprNode rExpr> (. declExpr = new ExprScaleNode(lExpr, rExpr, line, col); .)
.

Rotate<out ExprNode declExpr> =
    "rotate" (. int line = t.line; int col = t.col; .)
    Expr<out ExprNode lExpr>
    "around"
    Expr<out ExprNode mExpr>
    "by"
    Expr<out ExprNode rExpr> (. declExpr = new ExprRotateNode(lExpr, mExpr, rExpr, line, col); .)
.

/*-----------------------------------Expressions-----------------------------------*/
Expr<out ExprNode expr> =
    AndExpr<out expr>
    { "||" (. String op = t.val; int line = t.line; int col = t.col; .)
    AndExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

AndExpr<out ExprNode expr> =
    EqExpr<out expr>
    { "&&" (. String op = t.val; int line = t.line; int col = t.col; .)
    EqExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

EqExpr<out ExprNode expr> =
    RelExpr<out expr>
    { ( "==" | "!=") (. String op = t.val; int line = t.line; int col = t.col; .)
    RelExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

RelExpr<out ExprNode expr> =
    ConcatExpr<out expr>
    { ( "<=" | "<" | ">=" | ">" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    ConcatExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

ConcatExpr<out ExprNode expr> =
    PlusExpr<out expr>
    { "++" (. String op = t.val; int line = t.line; int col = t.col; .)
    PlusExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

PlusExpr<out ExprNode expr> =
    MultExpr<out expr>
    { ( "+" | "-" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    MultExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

MultExpr<out ExprNode expr> =
    NotExpr<out expr>
    { ( "*" | "/" ) (. String op = t.val; int line = t.line; int col = t.col; .)
    NotExpr<out ExprNode right> (. expr = makeBinOpExpr(expr, op, right, line, col); .)
    }
.

NotExpr<out ExprNode expr>          (. List<Character> unaries = new ArrayList(); int line = -1; int col = -1; .)
    = { ( '!' (. unaries.add('!'); .)
        | '-' (. unaries.add('-'); .) ) (. line = t.line; col = t.col; .)
      } Term<out expr>    (. expr = makeUnOpExpr(unaries, expr, line, col);  .)
.

Term<out ExprNode expr> = (. expr = null; .)
    (   IDENT (. String ident = t.val; int line = t.line; int col = t.col; .) (. expr = new ExprIdentifierNode(ident, line, col); .)
        [ ( ExprListAccess<out expr, ident, line, col>
          | ExprFuncCall<out expr, ident, line, col> ) ]
    |   ExprListDeclaration<out expr>
    |   INT     (. expr = new ExprIntNode(t.val, t.line, t.col); .)
    |   DOUBLE  (. expr = new ExprDoubleNode(t.val, t.line, t.col); .)
    |   STRING  (. expr = new ExprStringNode(t.val, t.line, t.col); .)
    |   ( "true" | "false" )  (. expr = new ExprBoolNode(t.val, t.line, t.col); .)
    |   "(" Expr<out expr> ")" )
.

ExprFuncCall<out ExprFunctionCallNode funcCall, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "("
    [Expr<out ExprNode arg> (. exprList.add(arg); .)
    { "," Expr<out arg> (. exprList.add(arg); .)
    }]
    ")" (. funcCall = new ExprFunctionCallNode(ident, exprList, line, col); .)
.

ExprListAccess<out ExprNode expr, String ident, int line, int col> = (. List<ExprNode> exprList = new ArrayList<>(); .)
    "["
    Expr<out expr> (. exprList.add(expr); .)
    "]"
    {
    "["
    Expr<out expr> (. exprList.add(expr); .)
    "]"
    } (. expr = new ExprListAccessNode(ident, exprList, line, col); .)
.

ExprListDeclaration<out ExprNode expr> = (. List<ExprNode> exprs = new ArrayList<>(); .)
    "[" (. int line = t.line; int col = t.col; .)
    [ Expr<out expr> (. exprs.add(expr); .)
    ]
    { "," Expr<out expr> (. exprs.add(expr); .)
    }
    "]" (. expr = new ExprListDeclaration(exprs, line, col); .)
.

/*-----------------------------------Types-----------------------------------*/
DeclType<out TypeNode type> = (. type = null; .)
    ( "shape" (. type = new TypeShapeNode(t.line, t.col); .)
    | Type<out type> )
.

Type<out TypeNode type> = (. type = null; .)
    ( "int" (. type = new TypeIntNode(t.line, t.col); .)
    | "double" (. type = new TypeDoubleNode(t.line, t.col); .)
    | "bool" (. type = new TypeDoubleNode(t.line, t.col); .)
    | "string" (. type = new TypeStringNode(t.line, t.col); .)
    | "void" (. type = new TypeVoidNode(t.line, t.col); .)
    | "[" Type<out TypeNode innerType> "]" (. type = new TypeListNode(innerType, t.line, t.col); .) )
.
END Program. // Must refer to the same non-terminal as "COMPILER" at the top.